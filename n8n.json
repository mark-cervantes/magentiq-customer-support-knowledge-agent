{
  "name": "ü§ñ Customer Support Knowledge Agent (OpenRouter + BM25/Embeddings)",
  "nodes": [
    {
      "parameters": {
        "content": "## üì• INPUT VALIDATION\n\n**Purpose**: Validate incoming webhook requests\n- Extract question from POST body\n- Validate minimum question length  \n- Set retrieval mode (bm25 or emb)\n- Handle basic auth: magentiq/magentiq\n\n**Outputs**: Clean question + mode or validation error",
        "height": 200,
        "width": 300
      },
      "id": "Input Section Note",
      "name": "Input Section Note",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [140, 180]
    },
    {
      "parameters": {
        "path": "support-agent",
        "httpMethod": "POST",
        "responseMode": "lastNode",
        "authentication": "basicAuth",
        "basicAuth": {
          "user": "magentiq",
          "password": "magentiq"
        }
      },
      "id": "Webhook",
      "name": "üåê Webhook Input",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 400],
      "color": "#1f77b4"
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "// Execution mode: Run Once\nconst items = $input.all();\nconst out = [];\n\nfor (const it of items) {\n  const body = it.json || {};\n  const q = String(body.question ?? \"\").trim();\n\n  // Prefer body.mode; optionally accept query-style if your webhook passes it\n  const bodyMode = (body.mode || \"\").toString().trim().toLowerCase();\n  const queryMode = (body.query?.mode || \"\").toString().trim().toLowerCase();\n  const envMode = ($env.RETRIEVAL_MODE || \"bm25\").toString().toLowerCase();\n\n  const modeRaw = bodyMode || queryMode || envMode;\n  const mode = modeRaw === \"emb\" ? \"emb\" : \"bm25\";\n\n  if (!q || q.length < 4) {\n    out.push({\n      json: {\n        valid: false,\n        error: true,\n        message:\n          \"Invalid input: body must include non-empty 'question' (min 4 chars).\",\n      },\n    });\n    continue;\n  }\n\n  // Optional guard to avoid bloated prompts\n  const MAX_Q = Number($env.MAX_QUESTION_CHARS || 1000);\n  const question = q.length > MAX_Q ? q.slice(0, MAX_Q) : q;\n\n  out.push({ json: { valid: true, error: false, question, mode } });\n}\n\nreturn out;"
      },
      "id": "Validate Input",
      "name": "‚úÖ Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [520, 400],
      "color": "#1f77b4"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.valid}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "IF Valid?",
      "name": "‚ùì Valid Input?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [760, 400],
      "color": "#1f77b4"
    },
    {
      "parameters": {
        "content": "## üìö KNOWLEDGE BASE LOADING\n\n**Purpose**: Load FAQ data from external JSON or embedded fallback\n- Check for OPEN_KB_JSON_URL environment variable\n- If URL exists: fetch external JSON\n- If no URL: use embedded 5-item FAQ\n- Normalize KB format: [{ id, title, content }]\n\n**Outputs**: Standardized KB array",
        "height": 200,
        "width": 300
      },
      "id": "KB Loading Note",
      "name": "KB Loading Note",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [900, 180]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$env.OPEN_KB_JSON_URL || ''}}",
              "operation": "notEqual",
              "value2": ""
            }
          ]
        }
      },
      "id": "IF Has KB URL?",
      "name": "üîó Has KB URL?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1020, 300],
      "color": "#2ca02c"
    },
    {
      "parameters": {
        "url": "={{$env.OPEN_KB_JSON_URL}}",
        "responseFormat": "json"
      },
      "id": "Load KB JSON",
      "name": "üåê Load External KB",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1260, 200],
      "color": "#2ca02c"
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "// Execution mode: Run Once\nreturn [\n  {\n    json: [\n      {\n        id: \"KB001\",\n        title: \"Password Reset\",\n        content:\n          \"To reset your account password, click 'Forgot Password' on the login page, enter your registered email address, and follow the instructions in the reset email.\",\n      },\n      {\n        id: \"KB002\",\n        title: \"Change Billing Address\",\n        content:\n          \"Log in to your account, go to 'Account Settings' > 'Billing', and click 'Edit Billing Address'. Save changes before exiting.\",\n      },\n      {\n        id: \"KB003\",\n        title: \"Cancel Subscription\",\n        content:\n          \"To cancel your subscription, go to 'Account Settings' > 'Subscription', select 'Cancel Subscription', and confirm the cancellation. Your subscription will remain active until the end of the billing cycle.\",\n      },\n      {\n        id: \"KB004\",\n        title: \"Refund Policy\",\n        content:\n          \"We offer a 30-day money-back guarantee on all annual subscriptions. Refunds are processed within 5-7 business days after approval.\",\n      },\n      {\n        id: \"KB005\",\n        title: \"Two-Factor Authentication\",\n        content:\n          \"Enable 2FA by navigating to 'Account Settings' > 'Security', clicking 'Enable Two-Factor Authentication', and scanning the QR code with an authenticator app.\",\n      },\n    ],\n  },\n];"
      },
      "id": "Embedded KB",
      "name": "üíæ Embedded KB",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1260, 400],
      "color": "#2ca02c"
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "// Execution mode: Run Once\nlet kb = [];\nconst first = $input.first();\nconst payload = first?.json;\n\n// Accept array, { kb: [...] }, or { data: [...] }\nif (Array.isArray(payload)) {\n  kb = payload;\n} else if (Array.isArray(payload?.kb)) {\n  kb = payload.kb;\n} else if (Array.isArray(payload?.data)) {\n  kb = payload.data;\n} else {\n  // Fallback embedded KB so the workflow runs out-of-the-box\n  kb = [\n    {\n      id: \"KB001\",\n      title: \"Password Reset\",\n      content:\n        \"To reset your account password, click 'Forgot Password' on the login page, \" +\n        \"enter your registered email address, and follow the instructions in the reset email.\",\n    },\n    {\n      id: \"KB002\",\n      title: \"Change Billing Address\",\n      content:\n        \"Log in to your account, go to 'Account Settings' > 'Billing', and click 'Edit Billing Address'. \" +\n        \"Save changes before exiting.\",\n    },\n    {\n      id: \"KB003\",\n      title: \"Cancel Subscription\",\n      content:\n        \"To cancel your subscription, go to 'Account Settings' > 'Subscription', select 'Cancel Subscription', \" +\n        \"and confirm the cancellation. Your subscription will remain active until the end of the billing cycle.\",\n    },\n    {\n      id: \"KB004\",\n      title: \"Refund Policy\",\n      content:\n        \"We offer a 30-day money-back guarantee on all annual subscriptions. \" +\n        \"Refunds are processed within 5-7 business days after approval.\",\n    },\n    {\n      id: \"KB005\",\n      title: \"Two-Factor Authentication\",\n      content:\n        \"Enable 2FA by navigating to 'Account Settings' > 'Security', clicking 'Enable Two-Factor Authentication', \" +\n        \"and scanning the QR code with an authenticator app.\",\n    },\n  ];\n}\n\nif (!Array.isArray(kb) || kb.length === 0) {\n  throw new Error(\"Knowledge base is empty or failed to load.\");\n}\n\n// Deduplicate, trim, enforce types\nconst seen = new Set();\nkb = kb\n  .filter((r) => r && r.id && r.content)\n  .filter((r) => {\n    const k = String(r.id).trim();\n    if (seen.has(k)) return false;\n    seen.add(k);\n    return true;\n  })\n  .map((r) => ({\n    id: String(r.id).trim(),\n    title: String(r.title || \"\").trim(),\n    content: String(r.content || \"\").trim(),\n  }));\n\nreturn [{ json: { kb } }];"
      },
      "id": "Normalize KB",
      "name": "üîÑ Normalize KB",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1480, 300],
      "color": "#2ca02c"
    },
    {
      "parameters": {
        "mode": "mergeByPosition"
      },
      "id": "Merge Q+KB",
      "name": "üîó Merge Question + KB",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [1700, 400],
      "color": "#2ca02c"
    },
    {
      "parameters": {
        "content": "## üîç RETRIEVAL ENGINE\n\n**BM25 Path (Orange)**: Keyword-based scoring\n- Tokenize question and documents\n- Calculate BM25 relevance scores\n- Return top-K most relevant entries\n- Zero external API calls\n\n**Embeddings Path (Purple)**: Semantic similarity\n- Generate embeddings via OpenRouter\n- Calculate cosine similarity\n- Return top-K most similar entries\n- Requires OpenRouter API key",
        "height": 200,
        "width": 300
      },
      "id": "Retrieval Note",
      "name": "Retrieval Note",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1820, 180]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.mode}}",
              "operation": "equal",
              "value2": "emb"
            }
          ]
        }
      },
      "id": "IF Embeddings?",
      "name": "üß† Use Embeddings?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1920, 400],
      "color": "#17becf"
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "// Execution mode: Run Once\nconst inItem = $input.first();\nif (!inItem) throw new Error(\"No input for BM25 Rank.\");\n\nconst { question, kb, mode } = inItem.json;\n\nfunction tokenize(text) {\n  return text\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s>\\/']/gi, \" \")\n    .split(/\\s+/)\n    .filter(Boolean)\n    .filter((t) => !STOP.has(t));\n}\n\nconst STOP = new Set([\n  \"a\",\n  \"an\",\n  \"the\",\n  \"and\",\n  \"or\",\n  \"but\",\n  \"if\",\n  \"then\",\n  \"than\",\n  \"so\",\n  \"to\",\n  \"of\",\n  \"in\",\n  \"a\",\n  \"on\",\n  \"for\",\n  \"with\",\n  \"as\",\n  \"by\",\n  \"is\",\n  \"are\",\n  \"was\",\n  \"were\",\n  \"be\",\n  \"been\",\n  \"at\",\n  \"it\",\n  \"this\",\n  \"that\",\n  \"these\",\n  \"those\",\n  \"we\",\n  \"you\",\n  \"your\",\n  \"our\",\n  \"i\",\n]);\n\nconst k1 = Number($env.BM25_K1 || 1.5);\nconst b = Number($env.BM25_B || 0.75);\n\nconst docs = kb.map((d) => ({\n  id: d.id,\n  title: d.title || \"\",\n  content: d.content || \"\",\n  tokens: tokenize(`${d.title || \"\"} ${d.content || \"\"}`),\n}));\n\nconst N = docs.length;\nconst docLens = docs.map((d) => d.tokens.length);\nconst avgdl = docLens.reduce((a, b) => a + b, 0) / Math.max(N, 1);\n\nconst df = new Map();\nfor (const d of docs) {\n  const uniq = new Set(d.tokens);\n  for (const t of uniq) df.set(t, (df.get(t) || 0) + 1);\n}\n\nconst idf = new Map();\nfor (const [t, n_i] of df.entries()) {\n  idf.set(t, Math.log((N - n_i + 0.5) / (n_i + 0.5) + 1));\n}\n\nfor (const d of docs) {\n  d.tf = new Map();\n  for (const t of d.tokens) d.tf.set(t, (d.tf.get(t) || 0) + 1);\n}\n\nconst qTokens = tokenize(question || \"\");\nconst scored = docs.map((d, idx) => {\n  let s = 0;\n  for (const t of qTokens) {\n    const f = d.tf.get(t) || 0;\n    if (f === 0) continue;\n    const idf_t = idf.get(t) || 0;\n    const denom = f + k1 * (1 - b + (b * docLens[idx]) / avgdl);\n    s += idf_t * ((f * (k1 + 1)) / Math.max(denom, 1e-9));\n  }\n  return { d, score: s };\n});\n\nconst max = Math.max(...scored.map((x) => x.score), 0);\nconst min = Math.min(...scored.map((x) => x.score), 0);\nconst normed = scored\n  .map((x) => ({\n    ...x,\n    norm: max === min ? 0 : (x.score - min) / (max - min),\n  }))\n  .sort((a, b) => b.norm - a.norm);\n\nconst top_k = Math.min(\n  parseInt($env.TOP_K || \"3\", 10),\n  Math.max(0, kb.length),\n);\n\nconst selected = normed.slice(0, top_k).filter((x) => x.norm > 0);\nconst selectedDocs = selected.map((x) => ({\n  id: x.d.id,\n  title: x.d.title,\n  content: x.d.content,\n  score: x.norm,\n}));\n\nreturn [\n  {\n    json: {\n      question,\n      mode: mode || \"bm25\",\n      retrieval: {\n        method: \"bm25\",\n        top_k,\n        selected: selectedDocs,\n        retrieval_conf: selected.length ? selected[0].norm : 0,\n      },\n    },\n  },\n];"
      },
      "id": "BM25 Rank",
      "name": "üìä BM25 Keyword Scoring",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2140, 580],
      "color": "#ff7f0e"
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "// Execution mode: Run Once\nconst inItem = $input.first();\nif (!inItem) throw new Error(\"No input for Prepare Embeddings.\");\n\nconst { kb, question } = inItem.json;\n\nreturn [\n  {\n    json: {\n      question,\n      mode: \"emb\",\n      texts: kb.map((d) => `${d.title || \"\"}\\n\\n${d.content || \"\"}`),\n      meta: kb.map((d) => ({ id: d.id, title: d.title || \"\" })),\n    },\n  },\n];"
      },
      "id": "Prepare Embeddings",
      "name": "üìù Prepare Embedding Texts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2140, 220],
      "color": "#9467bd"
    },
    {
      "parameters": {
        "url": "https://openrouter.ai/api/v1/embeddings",
        "method": "POST",
        "jsonParameters": true,
        "responseFormat": "json",
        "headerParametersJson": "={\n  \"Authorization\": \"Bearer {{$env.OPENROUTER_API_KEY}}\",\n  \"Content-Type\": \"application/json\"\n}",
        "bodyParametersJson": "={\n  \"model\": \"openai/text-embedding-3-small\",\n  \"input\": {{$json.texts}}\n}"
      },
      "id": "Doc Embeddings",
      "name": "üß† Generate Doc Embeddings",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [2360, 120],
      "color": "#9467bd"
    },
    {
      "parameters": {
        "url": "https://openrouter.ai/api/v1/embeddings",
        "method": "POST",
        "jsonParameters": true,
        "responseFormat": "json",
        "headerParametersJson": "={\n  \"Authorization\": \"Bearer {{$env.OPENROUTER_API_KEY}}\",\n  \"Content-Type\": \"application/json\"\n}",
        "bodyParametersJson": "={\n  \"model\": \"openai/text-embedding-3-small\",\n  \"input\": {{$json.question}}\n}"
      },
      "id": "Query Embedding",
      "name": "‚ùì Generate Query Embedding",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [2360, 320],
      "color": "#9467bd"
    },
    {
      "parameters": {
        "mode": "mergeByPosition"
      },
      "id": "Merge Doc + Meta",
      "name": "üîó Merge Doc Embeddings",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [2580, 220],
      "color": "#9467bd"
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "// Execution mode: Run Once\nconst j = $input.first().json;\nreturn [\n  {\n    json: {\n      doc_embeddings: Array.isArray(j.data)\n        ? j.data.map((d) => d.embedding)\n        : [],\n      texts: j.texts || [],\n      meta: j.meta || [],\n      question: j.question,\n      mode: j.mode || \"emb\",\n    },\n  },\n];"
      },
      "id": "Wrap Doc+Meta",
      "name": "üì¶ Package Doc Embeddings",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2800, 220],
      "color": "#9467bd"
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "// Execution mode: Run Once\nconst j = $input.first().json;\nconst qEmb =\n  Array.isArray(j.data) &&\n  j.data[0] &&\n  Array.isArray(j.data[0].embedding)\n    ? j.data[0].embedding\n    : [];\nreturn [{ json: { query_embedding: qEmb } }];"
      },
      "id": "Wrap Query Embedding",
      "name": "üì¶ Package Query Embedding",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2580, 420],
      "color": "#9467bd"
    },
    {
      "parameters": {
        "mode": "mergeByPosition"
      },
      "id": "Merge Embeddings",
      "name": "üîó Merge All Embeddings",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [3000, 320],
      "color": "#9467bd"
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "// Execution mode: Run Once\nfunction cosine(a, b) {\n  let dot = 0;\n  let na = 0;\n  let nb = 0;\n  const len = Math.min(a.length, b.length);\n  for (let i = 0; i < len; i++) {\n    const x = a[i];\n    const y = b[i];\n    dot += x * y;\n    na += x * x;\n    nb += y * y;\n  }\n  if (!na || !nb) return 0;\n  return dot / (Math.sqrt(na) * Math.sqrt(nb));\n}\n\nconst j = $input.first().json;\nconst docEmb = j.doc_embeddings || [];\nconst qEmb = j.query_embedding || [];\nconst texts = j.texts || [];\nconst meta = j.meta || [];\nconst question = j.question;\nconst mode = j.mode || \"emb\";\n\nif (!docEmb.length || !qEmb.length) {\n  return [\n    {\n      json: {\n        question,\n        mode,\n        retrieval: { method: \"emb\", top_k: 0, selected: [], retrieval_conf: 0 },\n      },\n    },\n  ];\n}\n\nconst scores = docEmb.map((e, i) => ({ idx: i, score: cosine(e, qEmb) }));\nconst maxS = Math.max(...scores.map((s) => s.score), 0);\nconst minS = Math.min(...scores.map((s) => s.score), 0);\nconst norm = scores\n  .map((s) => ({\n    ...s,\n    norm: maxS === minS ? 0 : (s.score - minS) / (maxS - minS),\n  }))\n  .sort((a, b) => b.norm - a.norm);\n\nconst top_k = Math.min(parseInt($env.TOP_K || \"3\", 10), texts.length);\nconst selected = norm.slice(0, top_k);\nconst selectedDocs = selected.map((s) => ({\n  id: meta[s.idx]?.id ?? String(s.idx),\n  title: meta[s.idx]?.title ?? \"\",\n  content: texts[s.idx],\n  score: s.norm,\n}));\n\nreturn [\n  {\n    json: {\n      question,\n      mode,\n      retrieval: {\n        method: \"emb\",\n        top_k,\n        selected: selectedDocs,\n        retrieval_conf: selected.length ? selected[0].norm : 0,\n      },\n    },\n  },\n];"
      },
      "id": "Rank Embeddings",
      "name": "üìà Cosine Similarity Ranking",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3220, 320],
      "color": "#9467bd"
    },
    {
      "parameters": {
        "content": "## ü§ñ LLM PROCESSING\n\n**Purpose**: Generate structured answers using retrieved context\n- Build system + user prompt with KB context\n- Call Claude 3.5 Sonnet via OpenRouter\n- Parse and validate JSON response\n- Blend retrieval confidence with model confidence\n- Return structured answer with sources\n\n**Output**: { answer, confidence_score, sources }",
        "height": 200,
        "width": 300
      },
      "id": "LLM Processing Note",
      "name": "LLM Processing Note",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [3280, 480]
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "// Execution mode: Run Once\nconst j = $input.first().json;\nconst question = j.question || \"\";\nconst retrieval = j.retrieval || { selected: [], retrieval_conf: 0 };\n\nconst contexts = (retrieval.selected || [])\n  .map((d, i) => {\n    const safe = (s) => String(s ?? \"\").replace(/\"/g, '\\\\\"');\n    return `KB[${i + 1}]: { \"id\": \"${safe(d.id)}\", \"title\": \"${safe(\n      d.title,\n    )}\", \"content\": \"${safe(d.content)}\" }`;\n  })\n  .join(\"\\n\\n\");\n\nconst schema = {\n  type: \"object\",\n  required: [\"answer\", \"confidence_score\", \"sources\"],\n  properties: {\n    answer: { type: \"string\" },\n    confidence_score: { type: \"number\", minimum: 0, maximum: 1 },\n    sources: { type: \"array\", items: { type: \"string\" }, minItems: 0 },\n  },\n};\n\nconst system = `\nYou are a Customer Support Knowledge Agent.\nRules:\n- Only answer using the provided KB contexts.\n- If contexts are insufficient, say you don't have enough info and suggest next steps or escalation. Do not invent facts.\n- Be concise and task-oriented for customers.\n- Output must be a single JSON object and valid JSON, no extra text.\n- Follow this JSON schema exactly (types and keys):\n${JSON.stringify(schema)}\n`.trim();\n\nconst user = `\nUser question:\n\"${question}\"\n\nRelevant contexts:\n${contexts}\n\nInstructions:\n1) Use only these contexts to answer.\n2) List sources as an array of KB ids you used (e.g., [\"KB001\"]).\n3) Set confidence_score between 0 and 1.\n4) If you cannot answer from the contexts, return a helpful message and set confidence_score <= 0.4.\n\nReturn only JSON.\n`.trim();\n\nreturn [\n  {\n    json: {\n      messages: [\n        { role: \"system\", content: system },\n        { role: \"user\", content: user },\n      ],\n      question,\n      mode: j.mode || \"bm25\",\n      retrieval,\n      retrieval_conf: retrieval.retrieval_conf || 0,\n    },\n  },\n];"
      },
      "id": "Build Prompt",
      "name": "üìù Build LLM Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3440, 400],
      "color": "#d62728"
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "// Execution mode: Run Once\nconst j = $input.first().json;\nreturn [\n  {\n    json: {\n      question: j.question,\n      mode: j.mode,\n      retrieval: j.retrieval,\n      retrieval_conf: j.retrieval_conf,\n    },\n  },\n];"
      },
      "id": "Extract Meta",
      "name": "üìä Extract Metadata",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3660, 580],
      "color": "#d62728"
    },
    {
      "parameters": {
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "method": "POST",
        "jsonParameters": true,
        "responseFormat": "json",
        "headerParametersJson": "={\n  \"Authorization\": \"Bearer {{$env.OPENROUTER_API_KEY}}\",\n  \"HTTP-Referer\": \"{{$env.OPENROUTER_SITE_URL || 'http://localhost'}}\",\n  \"X-Title\": \"CS Knowledge Agent\",\n  \"Content-Type\": \"application/json\"\n}",
        "bodyParametersJson": "={\n  \"model\": \"anthropic/claude-3.5-sonnet\",\n  \"messages\": {{$json.messages}},\n  \"temperature\": 0.2,\n  \"top_p\": 1\n}"
      },
      "id": "OpenRouter Chat",
      "name": "üß† Claude 3.5 Sonnet",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [3660, 240],
      "color": "#d62728"
    },
    {
      "parameters": {
        "mode": "mergeByPosition"
      },
      "id": "Merge LLM + Meta",
      "name": "üîó Merge LLM + Metadata",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [3880, 400],
      "color": "#d62728"
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "// Execution mode: Run Once\nfunction clamp(x, lo, hi) {\n  return Math.max(lo, Math.min(hi, x));\n}\n\nconst j = $input.first().json;\nconst retrieval_conf = Number(j.retrieval_conf ?? 0) || 0;\nconst question = j.question;\nconst mode = j.mode || \"bm25\";\nconst retrieval = j.retrieval || { selected: [] };\n\nconst raw = j?.choices?.[0]?.message?.content;\nif (!raw || typeof raw !== \"string\") {\n  return [\n    {\n      json: {\n        error: true,\n        message: \"LLM call failed or returned no content\",\n        details: j,\n        question,\n        mode,\n      },\n    },\n  ];\n}\n\nlet parsed;\ntry {\n  parsed = JSON.parse(raw);\n} catch {\n  const m = raw.match(/\\{[\\s\\S]*\\}/);\n  if (m) {\n    try {\n      parsed = JSON.parse(m[0]);\n    } catch {\n      return [\n        {\n          json: {\n            error: true,\n            message: \"LLM returned invalid JSON and repair failed.\",\n            details: { raw },\n            question,\n            mode,\n          },\n        },\n      ];\n    }\n  } else {\n    return [\n      {\n        json: {\n          error: true,\n          message: \"LLM returned invalid JSON.\",\n          details: { raw },\n          question,\n          mode,\n        },\n      ],\n    };\n  }\n}\n\nif (typeof parsed.answer !== \"string\") {\n  return [\n    {\n      json: {\n        error: true,\n        message: \"Invalid schema: 'answer' must be string.\",\n        details: parsed,\n        question,\n        mode,\n      },\n    },\n  ];\n}\nif (\n  typeof parsed.confidence_score !== \"number\" ||\n  Number.isNaN(parsed.confidence_score)\n) {\n  return [\n    {\n      json: {\n        error: true,\n        message: \"Invalid schema: 'confidence_score' must be number.\",\n        details: parsed,\n        question,\n        mode,\n      },\n    },\n  ];\n}\nif (!Array.isArray(parsed.sources)) {\n  return [\n    {\n      json: {\n        error: true,\n        message: \"Invalid schema: 'sources' must be array.\",\n        details: parsed,\n        question,\n        mode,\n      },\n    },\n  ];\n}\n\n// Blend confidence\nconst blended =\n  0.6 * clamp(parsed.confidence_score, 0, 1) +\n  0.4 * clamp(retrieval_conf, 0, 1);\n\n// Sanitize sources to allowed IDs coming from retrieval\nconst allowedIds = new Set(\n  (retrieval.selected || []).map((s) => String(s.id).trim()),\n);\nlet sources = Array.from(\n  new Set(\n    (parsed.sources || [])\n      .map((s) => String(s).trim())\n      .filter(Boolean),\n  ),\n).filter((s) => allowedIds.has(s));\n\nif (sources.length === 0 && (retrieval.selected || []).length > 0) {\n  sources = [String(retrieval.selected[0].id)];\n}\n\nreturn [\n  {\n    json: {\n      error: false,\n      result: {\n        answer: parsed.answer.trim(),\n        confidence_score: clamp(Number(blended.toFixed(3)), 0, 1),\n        sources,\n      },\n      question,\n      mode,\n      retrieval_method: retrieval.method || null,\n    },\n  },\n];"
      },
      "id": "Validate/Repair JSON",
      "name": "‚úÖ Validate JSON Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4100, 400],
      "color": "#d62728"
    },
    {
      "parameters": {
        "content": "## üì§ OUTPUT FORMATTING\n\n**Purpose**: Format final response and handle errors\n- Check for processing errors\n- Shape successful response with input echo\n- Build structured error response if needed\n- Return JSON via webhook response\n\n**Success**: { input: {...}, result: { answer, confidence_score, sources } }\n**Error**: { error: true, message: \"...\", details: {...} }",
        "height": 200,
        "width": 300
      },
      "id": "Output Note",
      "name": "Output Note",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [4200, 180]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.error}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "IF Result Has Error?",
      "name": "‚ùå Has Error?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [4320, 400],
      "color": "#bcbd22"
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "// Execution mode: Run Once\nconst j = $input.first().json;\nreturn [\n  {\n    json: {\n      input: { question: j.question, mode: j.mode },\n      result: j.result,\n    },\n  },\n];"
      },
      "id": "Shape Response",
      "name": "‚ú® Shape Success Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4540, 320],
      "color": "#bcbd22"
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "// Execution mode: Run Once\nconst j = $input.first().json;\nconst errMsg = j.message || \"Agent failed to answer.\";\nreturn [\n  {\n    json: {\n      error: true,\n      message: errMsg,\n      details: j.details ?? null,\n      hint:\n        \"Ensure 'question' is provided and that KB URL/API credentials are valid.\",\n    },\n  },\n];"
      },
      "id": "Build Error Payload",
      "name": "üí• Build Error Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4540, 480],
      "color": "#bcbd22"
    }
  ],
  "connections": {
    "Webhook": {
      "main": [[{ "node": "Validate Input", "type": "main", "index": 0 }]]
    },
    "Validate Input": {
      "main": [[{ "node": "IF Valid?", "type": "main", "index": 0 }]]
    },
    "IF Valid?": {
      "main": [
        [
          { "node": "IF Has KB URL?", "type": "main", "index": 0 },
          { "node": "Merge Q+KB", "type": "main", "index": 0 }
        ],
        [{ "node": "Build Error Payload", "type": "main", "index": 0 }]
      ]
    },
    "IF Has KB URL?": {
      "main": [
        [{ "node": "Load KB JSON", "type": "main", "index": 0 }],
        [{ "node": "Embedded KB", "type": "main", "index": 0 }]
      ]
    },
    "Load KB JSON": {
      "main": [[{ "node": "Normalize KB", "type": "main", "index": 0 }]]
    },
    "Embedded KB": {
      "main": [[{ "node": "Normalize KB", "type": "main", "index": 0 }]]
    },
    "Normalize KB": {
      "main": [[{ "node": "Merge Q+KB", "type": "main", "index": 1 }]]
    },
    "Merge Q+KB": {
      "main": [[{ "node": "IF Embeddings?", "type": "main", "index": 0 }]]
    },
    "IF Embeddings?": {
      "main": [
        [{ "node": "Prepare Embeddings", "type": "main", "index": 0 }],
        [{ "node": "BM25 Rank", "type": "main", "index": 0 }]
      ]
    },
    "BM25 Rank": {
      "main": [[{ "node": "Build Prompt", "type": "main", "index": 0 }]]
    },
    "Prepare Embeddings": {
      "main": [
        [
          { "node": "Doc Embeddings", "type": "main", "index": 0 },
          { "node": "Query Embedding", "type": "main", "index": 0 },
          { "node": "Merge Doc + Meta", "type": "main", "index": 1 }
        ]
      ]
    },
    "Doc Embeddings": {
      "main": [[{ "node": "Merge Doc + Meta", "type": "main", "index": 0 }]]
    },
    "Merge Doc + Meta": {
      "main": [[{ "node": "Wrap Doc+Meta", "type": "main", "index": 0 }]]
    },
    "Wrap Doc+Meta": {
      "main": [[{ "node": "Merge Embeddings", "type": "main", "index": 0 }]]
    },
    "Query Embedding": {
      "main": [[{ "node": "Wrap Query Embedding", "type": "main", "index": 0 }]]
    },
    "Wrap Query Embedding": {
      "main": [[{ "node": "Merge Embeddings", "type": "main", "index": 1 }]]
    },
    "Merge Embeddings": {
      "main": [[{ "node": "Rank Embeddings", "type": "main", "index": 0 }]]
    },
    "Rank Embeddings": {
      "main": [[{ "node": "Build Prompt", "type": "main", "index": 0 }]]
    },
    "Build Prompt": {
      "main": [
        [
          { "node": "OpenRouter Chat", "type": "main", "index": 0 },
          { "node": "Extract Meta", "type": "main", "index": 0 }
        ]
      ]
    },
    "OpenRouter Chat": {
      "main": [[{ "node": "Merge LLM + Meta", "type": "main", "index": 0 }]]
    },
    "Extract Meta": {
      "main": [[{ "node": "Merge LLM + Meta", "type": "main", "index": 1 }]]
    },
    "Merge LLM + Meta": {
      "main": [[{ "node": "Validate/Repair JSON", "type": "main", "index": 0 }]]
    },
    "Validate/Repair JSON": {
      "main": [[{ "node": "IF Result Has Error?", "type": "main", "index": 0 }]]
    },
    "IF Result Has Error?": {
      "main": [
        [{ "node": "Build Error Payload", "type": "main", "index": 0 }],
        [{ "node": "Shape Response", "type": "main", "index": 0 }]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "timezone": "America/New_York"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "id": "customer-support-kb-agent",
  "tags": []
}

